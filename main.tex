\documentclass[12pt]{report}
\usepackage[utf8]{inputenc}
\title{LABORATORY REPORT }
\author{University of Michigan - Shanghai Jiao Tong University}
\date{23 October 2024}
\renewcommand\thesection{\arabic{section}}
\usepackage{pdfpages}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{indentfirst} 
\usepackage{CJK}
\usepackage{hyperref}  
\usepackage{float}      
\usepackage[margin=2.5cm]{geometry} 
\usepackage{multirow}   
\usepackage{multicol}   
\usepackage{ulem}       
\usepackage{graphicx}   
\usepackage{subfig}     
\usepackage{amssymb}    
\usepackage{amsfonts}   
\usepackage{mathrsfs}   
\usepackage{latexsym}   
\usepackage{verbatim}
\usepackage{setspace}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage[backref=true,defernumbers=true,citestyle=numeric]{biblatex}
\addbibresource{references.bib}
% \usepackage{titlesec}
% \titleformat{\section}{\normalfont\Large\bfseries}{\thesection}{1em}{}
% \titleformat{\subsection}{\normalfont\large\bfseries}{\thesection.\arabic{\thesubsection}}{1em}{}

% \titleformat{\subsection}{\normalfont\Large\bfseries}{\thesubsection}{1em}{}

\hypersetup{
colorlinks=true,
linkcolor=black
}





\begin{document}
{\centering
\scshape{
\rule[-3pt]{16.5cm}{0.01mm}\\
\vspace{0.5cm}
\large UM-SJTU Joint Institute
\vspace{0.2cm}
\\ECE4810J 2024Fall System-on-Chip Design
\rule[3pt]{16.5cm}{0.01mm}\\
\vspace{0.2cm}
{\LARGE{Wishbone Bus Implementation}}\\
\vspace{0.2cm}
{\Large{Final Project}}\\


\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{cover.png}
    \label{fig:cover}
\end{figure}


\vspace{0.5cm}
Prof: DR. Xinfei Guo\\
}}
\vspace{0.3cm}


\vspace{0.5cm}

\begin{table}[h]
    \centering
    \begin{tabular}{l l l}
        \textbf{Name} & \textbf{Email} \\
         Muzi Li & muzili529@sjtu.edu.cn \\
         Lanqi Ding & dinglanqi20021215@sjtu.edu.cn \\
         Zhangsiyuan Jin & jzsiyuan@sjtu.edu.cn
    \end{tabular}
\end{table}

\newpage
\noindent
{\Large{\textbf{Abstract}}}
\\ \hspace*{\fill} \\
%This is a one page (or less) summary of the design problem, specifications, problem analysis, project plan, as well as the project outcome and motivation. It should provide key details and conclusions concisely.


This document presents 
\\

\noindent
\textbf{Key Words: }




\newpage

\doublespacing
\tableofcontents	% 目录
\thispagestyle{empty}
\clearpage


    
\setstretch{1.2}
\setlength{\parskip}{2mm}




\section{Introduction}
In the field of digital system design, particularly in the design of System-on-Chips (SoCs), the efficiency and reliability of communication between different hardware components are crucial. The Wishbone bus protocol, as a lightweight, open-source on-chip interconnect architecture, is widely adopted due to its simplicity and flexibility. Our project aims to implement this protocol to enhance the efficiency of data exchange between different Intellectual Property (IP) cores in SoCs, ensure the stability of communication, and meet the demands of modern electronic systems for high performance and scalability. The Wishbone bus, through its master-slave communication model, allows the master device to control data transfer while the slave device responds to requests, a model that excels in ensuring data consistency and reducing bus conflicts. Our solution will involve the detailed design and implementation of the Wishbone bus interface, including the maintenance of signal integrity, support for diverse data transfer methods, performance optimization, and considerations for compatibility and scalability. Our goal is to provide an efficient and reliable implementation of the Wishbone bus that not only meets current technical standards but can also adapt to future technological developments. Through this implementation, we expect to enhance system performance while simplifying the SoC design process, offering an effective solution for digital system design.\cite{Sharma_2012}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{wishbone.png}
    \label{fig:wishbone}
    \caption{Wishbone Bus}
\end{figure}

\section{Related Work}
Our project on the Wishbone bus architecture is situated within a rich landscape of existing research and development in the field of on-chip interconnection architectures. Prior work has explored various aspects of bus architectures, including their performance implications for System-on-Chip (SoC) designs. Notably, Sharma and Kumar's survey, "Wishbone bus Architecture - A Survey and Comparison," provides a comprehensive overview of the Wishbone bus architecture and its comparison with other on-chip bus architectures such as AMBA, CoreConnect, and Avalon. Their study highlights the Wishbone bus's advantages, such as its flexible arbitration scheme and additional data transfer cycle (Read-Modify-Write cycle),\cite{Sharma_2012} which aligns with our focus on enhancing the efficiency of data transfer within SoCs.

In addition to Sharma and Kumar's work, the OpenCores community has contributed several projects related to Wishbone, including an AXI to Wishbone bridge, which demonstrates the practical application and adaptability of the Wishbone protocol in connecting different bus systems.\cite{opencores_wishbone} These projects showcase the versatility of Wishbone in integrating with other protocols, which is relevant to our work as we aim to leverage Wishbone's compatibility features.

Furthermore, the "Double Wishbone Suspension Design Based on Design for Six Sigma (DFSS)" research, while not directly related to bus architectures, employs a robust design methodology that could be analogously applied to our project for optimizing the performance and reliability of the Wishbone bus implementation . This study's approach to minimizing variations and enhancing robustness provides a methodological perspective that may inform our optimization strategies.

Lastly, the "An Architecture and Compiler for Scalable On-Chip Communication" paper by Liang et al. introduces a scalable communication architecture for heterogeneous resources, which is another dimension of on-chip communication that our project touches upon, especially in terms of supporting high-bandwidth signal processing applications .

While our work is not entirely novel, it contributes to the existing body of knowledge by focusing specifically on the Wishbone bus and its integration within the context of modern SoC design challenges. We build upon these foundational works to address specific performance and optimization objectives that are critical for the advancement of on-chip interconnection technologies.



\section{Methods}

In this project, we implemented the Wishbone bus architecture using High-Level Synthesis (HLS) to facilitate the design and verification process. HLS allows us to describe the hardware behavior using high-level programming languages such as C and C++, which are then synthesized into RTL (Register Transfer Level) code. This approach significantly reduces the development time and complexity compared to traditional RTL design.

We divided our implementation into three main versions, each building upon the previous one to add more features and improve performance:

\begin{itemize}
    \item \textbf{Version 1 (v1)}: Primitive Read/Write Wishbone Master/Slave Implementation.
    \item \textbf{Version 2 (v2)}: Added support for \texttt{BASEADDR}, \texttt{SIZE}, and \texttt{OFFSET}.
    \item \textbf{Version 3 (v3)}: Introduced the \texttt{sel} signal for partial byte operations.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{v3_vitis_hls_co-simulation_report.png}
    \caption{Vitis HLS Co-simulation Report for v3}
    \label{fig:v3_vitis_hls_co-simulation_report}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{v3_block_design.png}
    \caption{Block Design for v3}
    \label{fig:v3_block_design}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{v3_implemented_design_highlight.png}
    \caption{Implemented Design Highlight for v3}
    \label{fig:v3_implemented_design_highlight}
\end{figure}

Each version was thoroughly tested using corresponding testbenches to ensure correctness and performance. The HLS tool used for this project was Vitis HLS, which provided an efficient workflow for synthesizing and verifying our designs.





\section{Methodology}

The methodology for implementing the Wishbone bus architecture using HLS involved several key steps:

\subsection{System Design and Integration}
The initial step involved designing the overall system architecture, including the Wishbone bus interface and its integration with other SoC components. This was achieved by defining the Wishbone protocol signals and their interactions within the system.

\subsection{High-Level Synthesis (HLS) Implementation}
The core functionality of the Wishbone bus was implemented using C++ in the HLS environment. The main components included:
\begin{itemize}
    \item \textbf{WishboneMaster}: Handles the generation of bus cycles and data transfer requests.
    \item \textbf{WishboneSlave}: Responds to the master's requests and performs read/write operations.
    \item \textbf{WishboneArbiter}: Manages the arbitration between multiple slaves and ensures correct data routing.
\end{itemize}

\subsection{Testing and Verification}
Each version of the implementation was tested using corresponding testbenches written in C. These testbenches simulated various scenarios, including normal operations, boundary conditions, and invalid addresses, to verify the correctness and robustness of the design.

\subsection{Performance Analysis and Optimization}
Performance metrics such as speed, latency, and throughput were measured to evaluate the efficiency of the Wishbone bus implementation. Optimization strategies were proposed and implemented to address any identified bottlenecks, ensuring that the system met the desired performance standards.




\section{Evaluation}

The evaluation of our Wishbone bus implementation involved several key aspects:

\subsection{Functional Verification}
Functional verification was performed using the testbenches developed for each version of the implementation. The testbenches covered a wide range of scenarios, including:
\begin{itemize}
    \item Basic read/write operations.
    \item Partial byte operations using the \texttt{sel} signal.
    \item Boundary condition testing.
    \item Cross-slave boundary operations.
    \item Handling of invalid addresses.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{v3_vitis_application_outcome.png}
    \caption{Vitis HLS Application Outcome for v3}
    \label{fig:v3_vitis_application_outcome}
\end{figure}

\subsection{Performance Analysis}
Performance metrics such as speed, latency, and throughput were measured to evaluate the efficiency of the Wishbone bus implementation. Each version of the implementation was synthesized using Vitis HLS, and the Timing Estimate from the Synthesis Summary was analyzed.

\subsubsection{Timing Estimate}
For versions v1 and v2, the Target Timing Estimate was 12ns. However, with the introduction of the \texttt{sel} signal in version v3, the Target Timing Estimate increased to 14ns. This increase in timing can be attributed to the additional logic required to handle partial byte operations, which introduces more complexity and potential delays in the data path.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{v3_vitis_hls_solution_report.png}
    \caption{Vitis HLS Solution Report for v3}
    \label{fig:v3_vitis_hls_solution_report}
\end{figure}

\subsubsection{Trade-off Analysis}
The introduction of the \texttt{sel} signal provides significant benefits in terms of flexibility and functionality, allowing for partial byte operations. However, this comes at the cost of increased timing, as seen in the Timing Estimate for v3. The trade-off between timing and functionality must be carefully considered based on the specific requirements of the application.

\paragraph{When to Use \texttt{sel} Signal}
The \texttt{sel} signal is particularly useful in scenarios where:
\begin{itemize}
    \item \textbf{Partial Byte Operations}: Applications that require frequent partial byte read/write operations can benefit from the \texttt{sel} signal, as it allows for more efficient data manipulation without the need for additional software handling.
    \item \textbf{Memory-Mapped I/O}: In systems with memory-mapped I/O, the \texttt{sel} signal can be used to access specific bytes within a word, improving the granularity of control and data access.
    \item \textbf{Performance Optimization}: For applications where the overhead of additional timing is acceptable, the \texttt{sel} signal can provide enhanced functionality and flexibility, leading to overall system performance improvements.
\end{itemize}

In conclusion, while the introduction of the \texttt{sel} signal in version v3 results in a slight increase in timing, the benefits it provides in terms of flexibility and functionality can outweigh the trade-offs in many applications. The decision to use the \texttt{sel} signal should be based on a careful analysis of the specific requirements and constraints of the target application.




\section{Statement of Work}
For the successful completion of the Wishbone Bus Implementation project, our team of three members has divided the work into three parts: System Design and Integration, Hardware Implementation and Debugging, Performance Analysis and Optimization.

\begin{itemize}
    \item Zhangsiyuan Jin: System Design and Integration

    She conducted a preliminary research on the Wishbone bus architecture through data collection and literature search, focusing on its protocols and interfaces. Then she designed a Wishbone compliant system architecture and integrated the bus with other SoC components. In addition, she developed a testbench and conducted simulations to verify the performance of the bus.

    \item Lanqi Ding: Hardware Implementation and Debugging

    She was responsible for crafting the high level synthesis (HLS) code for the Wishbone bus interface, bringing the design to life. She expertly implemented the arbitration logic and data transfer mechanisms that are essential for the bus's operation, ensuring efficient communication between components. When challenges arose during simulations and testing, Lanqi diligently debugged the design, pinpointing and resolving issues to maintain project momentum. 

    \item Muzi Li: Performance Analysis and Optimization

    She played a critical role in assessing the performance of the Wishbone bus implementation, diligently measuring key metrics like speed, latency, and throughput to ensure the system's efficiency. She identified performance bottlenecks and proposed targeted optimization strategies to boost the bus's capabilities. Working closely with Member A and Member B, they collaboratively implemented these enhancements, leading to significant improvements in the system's overall performance. Additionally, Member C was tasked with compiling the final report, which comprehensively detailed the performance analysis findings and the tangible benefits achieved through the implemented optimizations.


    
\end{itemize}














\section{Conclusion}

In this project, we successfully implemented the Wishbone bus architecture using High-Level Synthesis (HLS). Our implementation went through three major versions, each adding new features and improving performance. The use of HLS allowed us to efficiently design, verify, and optimize the Wishbone bus interface, significantly reducing development time compared to traditional RTL design methods.

\subsection{Key Achievements}
\begin{itemize}
    \item Developed a robust Wishbone bus interface with support for \texttt{BASEADDR}, \texttt{SIZE}, and \texttt{OFFSET}, and \texttt{sel} signals.
    \item Achieved functional verification through comprehensive testbenches covering various scenarios.
    \item Conducted performance analysis and optimization to ensure the implementation met the desired standards.
    \item Analyzed resource utilization to ensure efficient use of hardware resources.
\end{itemize}

\subsection{Future Work}
Future work could focus on further optimizing the Wishbone bus implementation for specific applications, exploring additional features such as dynamic reconfiguration, and integrating the Wishbone bus with other advanced on-chip communication protocols.

One promising area for future exploration is the introduction of a custom signal line, \texttt{TAGN}. The \texttt{TAGN} signal could be used to carry additional metadata or control information alongside the standard Wishbone signals. Potential applications of the \texttt{TAGN} signal include:

\begin{itemize}
    \item \textbf{Enhanced Debugging and Monitoring}: The \texttt{TAGN} signal could be used to tag specific transactions for debugging purposes, allowing for more granular monitoring and analysis of bus activity.
    \item \textbf{Quality of Service (QoS) Management}: By using the \texttt{TAGN} signal to indicate priority levels or other QoS parameters, the Wishbone bus could support differentiated services, ensuring that critical transactions receive the necessary bandwidth and latency guarantees.
    \item \textbf{Security and Access Control}: The \texttt{TAGN} signal could carry security-related information, such as access control tags, to enforce security policies and prevent unauthorized access to sensitive data.
    \item \textbf{Protocol Extensions}: The \texttt{TAGN} signal could be used to implement custom protocol extensions, enabling the Wishbone bus to support new features or interoperate with other bus protocols.
\end{itemize}

Exploring the implementation and integration of the \texttt{TAGN} signal within the Wishbone bus architecture could open up new possibilities for enhancing the functionality and versatility of the bus system. This line of research would involve defining the \texttt{TAGN} signal's specifications, developing the necessary hardware and software support, and evaluating its impact on system performance and complexity.

Overall, our project demonstrates the effectiveness of using HLS for designing complex on-chip interconnect architectures, providing a solid foundation for future developments in this area.





% References
\newpage
% \bibliographystyle{plain} % Change this to your required style
% \bibliography{references} % Your .bib file containing references
\printbibliography[title={References}, resetnumbers=true, heading=subbibliography]
\clearpage

\end{document}


